0001   
function void fibonacci(int n) 
              [0001, 0000] (0033,          PR_FUNCTION) {function}
              [0001, 0009] (0048,            TIPO_VOID) {void}
              [0001, 0014] (0000,                   ID) {fibonacci}
              [0001, 0023] (0018,             ABRE_PAR) {(}
              [0001, 0024] (0043,             TIPO_INT) {int}
              [0001, 0028] (0000,                   ID) {n}
              [0001, 0029] (0019,            FECHA_PAR) {)}
0002   
{
              [0002, 0000] (0022,           ABRE_CHAVE) {{}
0003   
	int n1 = 0, n2 = 1, n3;
              [0003, 0001] (0043,             TIPO_INT) {int}
              [0003, 0005] (0000,                   ID) {n1}
              [0003, 0008] (0016,               OP_ATR) {=}
              [0003, 0010] (0028,            CONST_INT) {0}
              [0003, 0011] (0025,                  SEP) {,}
              [0003, 0013] (0000,                   ID) {n2}
              [0003, 0016] (0016,               OP_ATR) {=}
              [0003, 0018] (0028,            CONST_INT) {1}
              [0003, 0019] (0025,                  SEP) {,}
              [0003, 0021] (0000,                   ID) {n3}
              [0003, 0023] (0024,             TERMINAL) {;}
0004   
	if(n == 0)
              [0004, 0001] (0039,                PR_IF) {if}
              [0004, 0003] (0018,             ABRE_PAR) {(}
              [0004, 0004] (0000,                   ID) {n}
              [0004, 0006] (0012,             OP_IGUAL) {==}
              [0004, 0009] (0028,            CONST_INT) {0}
              [0004, 0010] (0019,            FECHA_PAR) {)}
0005   
    {
              [0005, 0004] (0022,           ABRE_CHAVE) {{}
0006   
        write("%d", n);
              [0006, 0008] (0038,             PR_WRITE) {write}
              [0006, 0013] (0018,             ABRE_PAR) {(}
              [0006, 0014] (0031,         CONST_STRING) {"%d"}
              [0006, 0018] (0025,                  SEP) {,}
              [0006, 0020] (0000,                   ID) {n}
              [0006, 0021] (0019,            FECHA_PAR) {)}
              [0006, 0022] (0024,             TERMINAL) {;}
0007   
	}
              [0007, 0001] (0023,          FECHA_CHAVE) {}}
0008   
    if(n == 1)
              [0008, 0004] (0039,                PR_IF) {if}
              [0008, 0006] (0018,             ABRE_PAR) {(}
              [0008, 0007] (0000,                   ID) {n}
              [0008, 0009] (0012,             OP_IGUAL) {==}
              [0008, 0012] (0028,            CONST_INT) {1}
              [0008, 0013] (0019,            FECHA_PAR) {)}
0009   
    {
              [0009, 0004] (0022,           ABRE_CHAVE) {{}
0010   
        write("0, %d", n);
              [0010, 0008] (0038,             PR_WRITE) {write}
              [0010, 0013] (0018,             ABRE_PAR) {(}
              [0010, 0014] (0031,         CONST_STRING) {"0, %d"}
              [0010, 0021] (0025,                  SEP) {,}
              [0010, 0023] (0000,                   ID) {n}
              [0010, 0024] (0019,            FECHA_PAR) {)}
              [0010, 0025] (0024,             TERMINAL) {;}
0011   
	}
              [0011, 0001] (0023,          FECHA_CHAVE) {}}
0012   
    else
              [0012, 0004] (0040,              PR_ELSE) {else}
0013   
    {
              [0013, 0004] (0022,           ABRE_CHAVE) {{}
0014   
		string sep = ",";
              [0014, 0002] (0046,          TIPO_STRING) {string}
              [0014, 0009] (0000,                   ID) {sep}
              [0014, 0013] (0016,               OP_ATR) {=}
              [0014, 0015] (0031,         CONST_STRING) {","}
              [0014, 0018] (0024,             TERMINAL) {;}
0015   
		write("0, 1, ");
              [0015, 0002] (0038,             PR_WRITE) {write}
              [0015, 0007] (0018,             ABRE_PAR) {(}
              [0015, 0008] (0031,         CONST_STRING) {"0, 1, "}
              [0015, 0016] (0019,            FECHA_PAR) {)}
              [0015, 0017] (0024,             TERMINAL) {;}
0016   
		while(true)
              [0016, 0002] (0042,             PR_WHILE) {while}
              [0016, 0007] (0018,             ABRE_PAR) {(}
              [0016, 0008] (0000,                   ID) {true}
              [0016, 0012] (0019,            FECHA_PAR) {)}
0017   
        {
              [0017, 0008] (0022,           ABRE_CHAVE) {{}
0018   
			n3 = n1 + n2;
              [0018, 0003] (0000,                   ID) {n3}
              [0018, 0006] (0016,               OP_ATR) {=}
              [0018, 0008] (0000,                   ID) {n1}
              [0018, 0011] (0001,               OP_ADD) {+}
              [0018, 0013] (0000,                   ID) {n2}
              [0018, 0015] (0024,             TERMINAL) {;}
0019   
			write("%s%d", sep, n3);
              [0019, 0003] (0038,             PR_WRITE) {write}
              [0019, 0008] (0018,             ABRE_PAR) {(}
              [0019, 0009] (0031,         CONST_STRING) {"%s%d"}
              [0019, 0015] (0025,                  SEP) {,}
              [0019, 0017] (0000,                   ID) {sep}
              [0019, 0020] (0025,                  SEP) {,}
              [0019, 0022] (0000,                   ID) {n3}
              [0019, 0024] (0019,            FECHA_PAR) {)}
              [0019, 0025] (0024,             TERMINAL) {;}
0020   
			if (n3 >= n)
              [0020, 0003] (0039,                PR_IF) {if}
              [0020, 0006] (0018,             ABRE_PAR) {(}
              [0020, 0007] (0000,                   ID) {n3}
              [0020, 0010] (0013,          OP_MAIOR_IG) {>=}
              [0020, 0013] (0000,                   ID) {n}
              [0020, 0014] (0019,            FECHA_PAR) {)}
0021   
            {
              [0021, 0012] (0022,           ABRE_CHAVE) {{}
0022   
				return;
              [0022, 0004] (0036,            PR_RETURN) {return}
              [0022, 0010] (0024,             TERMINAL) {;}
0023   
			}
              [0023, 0003] (0023,          FECHA_CHAVE) {}}
0024   
			n1 = n2;
              [0024, 0003] (0000,                   ID) {n1}
              [0024, 0006] (0016,               OP_ATR) {=}
              [0024, 0008] (0000,                   ID) {n2}
              [0024, 0010] (0024,             TERMINAL) {;}
0025   
			n2 = n3;
              [0025, 0003] (0000,                   ID) {n2}
              [0025, 0006] (0016,               OP_ATR) {=}
              [0025, 0008] (0000,                   ID) {n3}
              [0025, 0010] (0024,             TERMINAL) {;}
0026   
		}
              [0026, 0002] (0023,          FECHA_CHAVE) {}}
0027   
	}
              [0027, 0001] (0023,          FECHA_CHAVE) {}}
0028   
}
              [0028, 0000] (0023,          FECHA_CHAVE) {}}
0029   
function void main()
              [0029, 0000] (0033,          PR_FUNCTION) {function}
              [0029, 0009] (0048,            TIPO_VOID) {void}
              [0029, 0014] (0035,              PR_MAIN) {main}
              [0029, 0018] (0018,             ABRE_PAR) {(}
              [0029, 0019] (0019,            FECHA_PAR) {)}
0030   
{
              [0030, 0000] (0022,           ABRE_CHAVE) {{}
0031   
	int n;
              [0031, 0001] (0043,             TIPO_INT) {int}
              [0031, 0005] (0000,                   ID) {n}
              [0031, 0006] (0024,             TERMINAL) {;}
0032   
	input(n);
              [0032, 0001] (0037,             PR_INPUT) {input}
              [0032, 0006] (0018,             ABRE_PAR) {(}
              [0032, 0007] (0000,                   ID) {n}
              [0032, 0008] (0019,            FECHA_PAR) {)}
              [0032, 0009] (0024,             TERMINAL) {;}
0033   
	fibonacci(n);
              [0033, 0001] (0000,                   ID) {fibonacci}
              [0033, 0010] (0018,             ABRE_PAR) {(}
              [0033, 0011] (0000,                   ID) {n}
              [0033, 0012] (0019,            FECHA_PAR) {)}
              [0033, 0013] (0024,             TERMINAL) {;}
0034   
}
              [0034, 0000] (0023,          FECHA_CHAVE) {}}
0035   
              [0035, 0002] (0027,            EOF_TOKEN) {EOF}
